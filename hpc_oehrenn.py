import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh
import argparse
import os
import time
import json
from datetime import datetime
import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor
import h5py

# Constants
hbar = 1.0  # Reduced Planck's constant (atomic units)
mass = 1.0  # Proton mass in atomic units

# Optimized Hamiltonian
def hamiltonian(x, y, parameters):
    """Compute the Hamiltonian with parameter dict - optimized but mathematically identical."""
    # Calculate z directly - avoid function call overhead
    if parameters['z_choice'] == 'constant':
        z = parameters['z_val']
    else:
        z = np.sqrt(x**2 + (1 - parameters['e']**2) * y**2)
    
    # Calculate off-diagonal term directly
    off_diag = x - 1j * np.sqrt(1 - parameters['e']**2) * y
    
    # Create and return Hamiltonian - no change in physics
    return 0.5*parameters['s'] * np.array([
        [parameters['a']*z, off_diag], 
        [np.conjugate(off_diag), -z]
    ], dtype=complex)

# z-function - simplified direct calculation
def z_func(x, y, parameters):
    """Compute z value with parameter dict."""
    if parameters['z_choice'] == 'constant':
        return parameters['z_val']
    else:
        # Direct calculation
        return np.sqrt(x**2 + (1 - parameters['e']**2) * y**2)

# Optimized eigenvectors calculation - NO CACHING
def eigenvectors(x, y, parameters):
    """Calculate eigenvectors of Hamiltonian - optimized but exact."""
    # Compute Hamiltonian
    H = hamiltonian(x, y, parameters)
    
    # Compute eigenvalues and eigenvectors directly
    eigenvalues, eigenvectors = np.linalg.eigh(H)
    
    # Normalize the eigenvectors - critical for quantum accuracy
    eigenvectors[:, 0] /= np.linalg.norm(eigenvectors[:, 0])
    eigenvectors[:, 1] /= np.linalg.norm(eigenvectors[:, 1])
    
    # Return as separate arrays for lower and upper states
    psi_lower = eigenvectors[:, 0]
    psi_upper = eigenvectors[:, 1]
    
    return psi_lower, psi_upper

# Berry phase calculation - NO CACHING, direct calculation each time
def berry_phase(x, y, parameters, state='lower'):
    """
    Calculate the analytical Berry phase for a state circling a conical intersection.
    Direct calculation ensures accuracy for each position.
    
    Parameters:
    - x, y: Position coordinates
    - parameters: Simulation parameters
    - state: Either 'lower' or 'upper' to specify which state
    
    Returns:
    - The exact Berry phase value
    """
    # Extract parameters directly
    e = parameters['e'] 
    a = parameters.get('a', 1.0)
    
    # Calculate z value - direct calculation for each call
    if parameters['z_choice'] == 'constant':
        z = parameters['z_val']
    else:
        z = np.sqrt(x**2 + (1 - e**2) * y**2)
    
    # Calculate radius
    r = np.sqrt(np.real(x)**2 + (1 - e**2) * np.real(y)**2)
    
    # Calculate denominator term (with safety check)
    denom = np.sqrt(4 * (1 - e**2) * r**2 + (1 + a)**2 * z**2)
    if denom < 1e-10:
        return 0.0
        
    # Calculate the term that differentiates upper and lower states
    term = (1 + a) * z / denom
    
    # Return the appropriate phase
    if state == 'lower':
        return np.pi * (1 - term)
    else:  # upper
        return np.pi * (1 + term)

def _berry_curvature_original(x, y, z, a, e, s):
    """Original Berry curvature function with individual parameters."""
    # Your existing analytical expression here
    bcl=(0+1j)*((1.*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**3 - (0.5*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2 - (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-0.75*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2.5) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*(1. - 1.*e**2)*y*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - ((0.+0.5j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*x*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (1.*(1. - 1.*e**2)*x*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) - ((0.+2j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**3*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) - ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))) - (0+1j)*((1.*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**3 - (0.5*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2 - (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-0.75*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2.5) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*(1. - 1.*e**2)*y*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - ((0.+0.5j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*x*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (1.*(1. - 1.*e**2)*x*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) - ((0.+2j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**3*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))))    
    curvature = np.abs(bcl)
    if not np.isfinite(curvature) or curvature > 1e16:
        return np.clip(curvature, -1e16, 1e16)
    
    return curvature
def _berry_curvature_original(x, y, z, a, e, s):
    """Original Berry curvature function with individual parameters."""
    # Your existing analytical expression here
    bcl=(0+1j)*((1.*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**3 - (0.5*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2 - (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-0.75*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2.5) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*(1. - 1.*e**2)*y*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - ((0.+0.5j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*x*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (1.*(1. - 1.*e**2)*x*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) - ((0.+2j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**3*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) - ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))) - (0+1j)*((1.*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**3 - (0.5*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2 - (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-0.75*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**2.5) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((2.*(1. - 1.*e**2)*x*y)/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (2.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) + (8.*(1. - 1.*e**2)*x*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**3))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*(1. - 1.*e**2)*y*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - ((0.+0.5j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (0.5*x*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) + (1.*(1. - 1.*e**2)*x*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)**1.5*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*x)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) - ((0.+2j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**3*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*x*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2)*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*x*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + (1.*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((0.5*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x**2 + (1. - 1.*e**2)*y**2)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)**2))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))) + ((0.+1j)*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2)))/((1.*x + (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2)))))/((1.*x - (0.+1j)*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*np.sqrt(1.*x**2 + (1. - 1.*e**2)*y**2 + 0.25*(1. + 1.*a)**2*z**2))**2)/(1.*x**2 + (1. - 1.*e**2)*y**2))))    
    curvature = np.abs(bcl)
    if not np.isfinite(curvature) or curvature > 1e16:
        return np.clip(curvature, -1e16, 1e16)
    
    return curvature

# Berry curvature calculation - NO CACHING, direct calculation
def berry_curvature(x, y, parameters):
    """
    Calculate Berry curvature without caching to ensure accuracy.
    
    Parameters:
    - x, y: Coordinates in space
    - parameters: Dictionary containing simulation parameters
    
    Returns:
    - Berry curvature value at the given point
    """
    try:
        # Extract needed parameters
        z = z_func(x, y, parameters)
        a = parameters['a']
        e = parameters['e']
        s = parameters['s']
        
        # Call the original function with the extracted parameters
        # This is the complex analytical expression from the original code
        bcl = _berry_curvature_original(x, y, z, a, e, s)
        
        # Return the absolute value with safety checks
        curvature = np.abs(bcl)
        if not np.isfinite(curvature) or curvature > 1e6:
            return np.clip(curvature, -1e6, 1e6)
        
        return curvature
    except Exception as e:
        if parameters.get('debug', False):
            print(f"Warning: Berry curvature calculation failed: {e}")
        return 0.0  # Return zero as fallback

# Non-Adiabatic Coupling calculation - optimized but exact
def nonadiabatic_coupling(x, y, state_i, state_j, parameters, delta=1e-4):
    """
    Compute first-order non-adiabatic coupling d_ij^x and d_ij^y for states i and j.
    Optimized implementation with no caching.
    """
    # Get eigenvectors at current position 
    psi_lower, psi_upper = eigenvectors(x, y, parameters)
    
    # Select states
    if state_i == 'lower':
        psi_i = psi_lower
    else:  # state_i == 'upper'
        psi_i = psi_upper
    
    if state_j == 'lower':
        psi_j = psi_lower
    else:  # state_j == 'upper'
        psi_j = psi_upper
    
    # Get eigenvectors at shifted positions - calculate once per direction
    psi_lower_dx, psi_upper_dx = eigenvectors(x + delta, y, parameters)
    psi_lower_dy, psi_upper_dy = eigenvectors(x, y + delta, parameters)
    
    # Select j states at shifted positions
    if state_j == 'lower':
        psi_j_dx = psi_lower_dx
        psi_j_dy = psi_lower_dy
    else:  # state_j == 'upper'
        psi_j_dx = psi_upper_dx
        psi_j_dy = psi_upper_dy
    
    # Calculate NAC components with finite differences
    d_ij_x = np.real(np.vdot(psi_i, psi_j_dx) - np.vdot(psi_i, psi_j)) / delta
    d_ij_y = np.real(np.vdot(psi_i, psi_j_dy) - np.vdot(psi_i, psi_j)) / delta
    
    return d_ij_x, d_ij_y

def berry_connection(x, y, parameters, delta=1e-4):
    """Calculate Berry connection A = -i|."""
    try:
        psi_lower, _ = eigenvectors(x, y, parameters)
        
        # Calculate wavefunctions at neighboring points
        psi_dx, _ = eigenvectors(x + delta, y, parameters)
        psi_dy, _ = eigenvectors(x, y + delta, parameters)
        
        # Ensure phase consistency
        if np.real(np.vdot(psi_lower, psi_dx)) < 0:
            psi_dx = -psi_dx
        if np.real(np.vdot(psi_lower, psi_dy)) < 0:
            psi_dy = -psi_dy
        
        # Calculate derivatives
        dpsi_dx = (psi_dx - psi_lower) / delta
        dpsi_dy = (psi_dy - psi_lower) / delta
        
        # Berry connection components
        Ax = np.real(-1j * np.vdot(psi_lower, dpsi_dx))
        Ay = np.real(-1j * np.vdot(psi_lower, dpsi_dy))
        
        return Ax, Ay
    except Exception as e:
        print(f"Warning: Berry connection calculation failed: {e}")
        return 0.0, 0.0  # Return zeros as fallback

def analytical_berry_connection(x, y, z, parameters):
    """
    Calculate Berry connection analytically for both eigenstates.
    
    Parameters:
    -----------
    x, y, z : float
        Coordinates in parameter space
    parameters : dict
        Dictionary containing 'a', 'e', and 's' values
        
    Returns:
    --------
    tuple
        (Ax_lower, Ay_lower, Ax_upper, Ay_upper)
    """
    # Extract parameters
    a = parameters['a']
    e = parameters['e']
    s = parameters['s']
    
    # Common terms - precompute to avoid repetition
    x2 = x**2
    y2 = y**2
    xy_term = x2 + (1-e**2)*y2
    sqrt_term = np.sqrt(x2 + (1-e**2)*y2 + 0.25*(1+a)**2*z**2)
    
    # Use proper complex number notation (1j instead of (0.,1.))
    complex_y = x + 1j*np.sqrt(1-e**2)*y
    complex_y_conj = x - 1j*np.sqrt(1-e**2)*y
    
    # Berry connection components for LOWER eigenstate
    # The formula is kept exactly the same, just fixing the complex number notation
    Ax_lower = -1j*((-0.5*((-2.*x*(0.5*z + 0.5*a*z - 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*x*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term)**2))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))**2 - (1.*(-0.5*z - 0.5*a*z + 1.*sqrt_term)*((0.5*(-0.5*z - 0.5*a*z + 1.*sqrt_term)*((-2.*x*(0.5*z + 0.5*a*z - 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*x*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term)**2))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))**1.5) - (1.*x)/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*sqrt_term*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))) + (1.*(-0.5*z - 0.5*a*z + 1.*sqrt_term))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term)))))/((1.*x - 1j*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))))

    Ay_lower = -1j*((-0.5*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term)**2))/(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))**2 - (1.*(-0.5*z - 0.5*a*z + 1.*sqrt_term)*((0.5*(-0.5*z - 0.5*a*z + 1.*sqrt_term)*((-2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term)**2))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))**1.5) - (1.*(1. - 1.*e**2)*y)/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*sqrt_term*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))) + (1j*np.sqrt(1. - 1.*e**2)*(-0.5*z - 0.5*a*z + 1.*sqrt_term))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term)))))/((1.*x - 1j*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z - 1.*sqrt_term)**2)/(1.*xy_term))))

    # Berry connection components for UPPER eigenstate
    Ax_upper = -1j*((-0.5*((2.*x*(0.5*z + 0.5*a*z + 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*x*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term)**2))/(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))**2 + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)*((-0.5*(0.5*z + 0.5*a*z + 1.*sqrt_term)*((2.*x*(0.5*z + 0.5*a*z + 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*x*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term)**2))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))**1.5) + (1.*x)/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*sqrt_term*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))) - (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term)))))/((1.*x - 1j*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))))

    Ay_upper = -1j*((-0.5*((2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z + 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term)**2))/(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))**2 + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)*((-0.5*(0.5*z + 0.5*a*z + 1.*sqrt_term)*((2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z + 1.*sqrt_term))/((1.*xy_term)*sqrt_term) - (2.*(1. - 1.*e**2)*y*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term)**2))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))**1.5) + (1.*(1. - 1.*e**2)*y)/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)*sqrt_term*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))) - (1j*np.sqrt(1. - 1.*e**2)*(0.5*z + 0.5*a*z + 1.*sqrt_term))/((1.*x + 1j*np.sqrt(1. - 1.*e**2)*y)**2*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term)))))/((1.*x - 1j*np.sqrt(1. - 1.*e**2)*y)*np.sqrt(1. + (1.*(0.5*z + 0.5*a*z + 1.*sqrt_term)**2)/(1.*xy_term))))

    return np.real(Ax_lower), np.real(Ay_lower), np.real(Ax_upper), np.real(Ay_upper)

# Second-order NAC calculation - optimized but mathematically identical
def second_order_nac(x, y, state_i, state_j, parameters, delta=1e-4):
    """Compute second-order non-adiabatic couplings d_ij^xx, d_ij^xy, d_ij^yy."""
    # Get eigenvectors at current position
    psi_lower, psi_upper = eigenvectors(x, y, parameters)
    
    # Select states
    if state_i == 'lower':
        psi_i = psi_lower
    else:  # state_i == 'upper'
        psi_i = psi_upper
    
    if state_j == 'lower':
        psi_j = psi_lower
    else:  # state_j == 'upper'
        psi_j = psi_upper
    
    # Compute wavefunctions at shifted positions - compute once per position
    psi_lower_xp, psi_upper_xp = eigenvectors(x + delta, y, parameters)
    psi_lower_xm, psi_upper_xm = eigenvectors(x - delta, y, parameters)
    psi_lower_yp, psi_upper_yp = eigenvectors(x, y + delta, parameters)
    psi_lower_ym, psi_upper_ym = eigenvectors(x, y - delta, parameters)
    psi_lower_pp, psi_upper_pp = eigenvectors(x + delta, y + delta, parameters)
    psi_lower_pm, psi_upper_pm = eigenvectors(x + delta, y - delta, parameters)
    psi_lower_mp, psi_upper_mp = eigenvectors(x - delta, y + delta, parameters)
    psi_lower_mm, psi_upper_mm = eigenvectors(x - delta, y - delta, parameters)
    
    # Select j states at shifted positions
    if state_j == 'lower':
        psi_j_xp = psi_lower_xp
        psi_j_xm = psi_lower_xm
        psi_j_yp = psi_lower_yp
        psi_j_ym = psi_lower_ym
        psi_j_pp = psi_lower_pp
        psi_j_pm = psi_lower_pm
        psi_j_mp = psi_lower_mp
        psi_j_mm = psi_lower_mm
    else:  # state_j == 'upper'
        psi_j_xp = psi_upper_xp
        psi_j_xm = psi_upper_xm
        psi_j_yp = psi_upper_yp
        psi_j_ym = psi_upper_ym
        psi_j_pp = psi_upper_pp
        psi_j_pm = psi_upper_pm
        psi_j_mp = psi_upper_mp
        psi_j_mm = psi_upper_mm
    
    # Second derivatives using finite differences
    d2_psi_j_dx2 = (psi_j_xp - 2 * psi_j + psi_j_xm) / (delta**2)
    d2_psi_j_dy2 = (psi_j_yp - 2 * psi_j + psi_j_ym) / (delta**2)
    d2_psi_j_dxdy = (psi_j_pp - psi_j_pm - psi_j_mp + psi_j_mm) / (4 * delta**2)
    
    # Compute second-order couplings
    d_ij_xx = np.real(np.vdot(psi_i, d2_psi_j_dx2))
    d_ij_xy = np.real(np.vdot(psi_i, d2_psi_j_dxdy))
    d_ij_yy = np.real(np.vdot(psi_i, d2_psi_j_dy2))
    
    return d_ij_xx, d_ij_xy, d_ij_yy

# Optimized Hamiltonian derivatives
def dh_dx(x, y, parameters, delta=1e-6):
    """Calculate x-derivative of Hamiltonian with optimized finite difference."""
    # Calculate Hamiltonians once for each position
    H_plus = hamiltonian(x + delta, y, parameters)
    H_minus = hamiltonian(x - delta, y, parameters)
    
    # Use central difference for better accuracy
    return (H_plus - H_minus) / (2 * delta)

def dh_dy(x, y, parameters, delta=1e-6):
    """Calculate y-derivative of Hamiltonian with optimized finite difference."""
    # Calculate Hamiltonians once for each position
    H_plus = hamiltonian(x, y + delta, parameters)
    H_minus = hamiltonian(x, y - delta, parameters)
    
    # Use central difference for better accuracy
    return (H_plus - H_minus) / (2 * delta)

def evolve_classical(x, y, vx, vy, psi, dt, H, parameters):
    """
    Evolve classical variables with improved Velocity Verlet algorithm.
    Uses a more robust approach to time-stepping.
    
    Parameters:
    - x, y: Current positions
    - vx, vy: Current velocities
    - psi: Current quantum state
    - dt: Time step
    - H: Current Hamiltonian
    - parameters: Simulation parameters
    
    Returns:
    - Updated state variables
    """
    # Calculate initial energy
    energy_old = np.real(np.vdot(psi, np.dot(H, psi))) + 0.5 * mass * (vx**2 + vy**2)
    
    # Set minimum time step and maximum retries
    min_dt = dt * 1e-3  # Increased minimum dt to prevent freezing
    current_dt = dt
    max_retries = 5     # Reduced from 10 to avoid excessive time-step reduction
    
    for attempt in range(max_retries):
        # Compute initial force
        fx, fy = force(psi, x, y, vx, vy, parameters)
        
        # Half-step velocity update
        vx_half = vx + 0.5 * fx / mass * current_dt
        vy_half = vy + 0.5 * fy / mass * current_dt
        
        # Full-step position update
        x_new = x + vx_half * current_dt
        y_new = y + vy_half * current_dt
        
        # Update Hamiltonian and quantum state
        H_new = hamiltonian(x_new, y_new, parameters)
        psi_new = evolve_psi(psi, H, H_new, current_dt, x, y, x_new, y_new, vx_half, vy_half, parameters)
        
        # Compute new force with updated state
        fx_new, fy_new = force(psi_new, x_new, y_new, vx_half, vy_half, parameters)
        
        # Full-step velocity update
        vx_new = vx_half + 0.5 * fx_new / mass * current_dt
        vy_new = vy_half + 0.5 * fy_new / mass * current_dt
        
        # Calculate new energy
        energy_new = np.real(np.vdot(psi_new, np.dot(H_new, psi_new))) + 0.5 * mass * (vx_new**2 + vy_new**2)
        
        # Check energy conservation
        energy_scale = max(abs(energy_old), abs(energy_new), 1e-6)
        rel_energy_error = abs(energy_new - energy_old) / energy_scale
        
        # More forgiving energy conservation threshold
        threshold = parameters.get('energy_threshold', 1e-4) * 10.0  # Made 10x more forgiving
        
        if rel_energy_error < threshold or current_dt <= min_dt:
            # Success or reached minimum time step
            return x_new, y_new, vx_new, vy_new, H_new, psi_new
        
        # Reduce time step more cautiously
        current_dt *= 0.5
        
        # Don't go below minimum time step
        if current_dt < min_dt:
            current_dt = min_dt
    
    # If all retries fail, still return the result with the smallest time step
    # This prevents trajectories from getting completely stuck
    fx, fy = force(psi, x, y, vx, vy, parameters)
    vx_half = vx + 0.5 * fx / mass * current_dt
    vy_half = vy + 0.5 * fy / mass * current_dt
    x_new = x + vx_half * current_dt
    y_new = y + vy_half * current_dt
    H_new = hamiltonian(x_new, y_new, parameters)
    psi_new = evolve_psi(psi, H, H_new, current_dt, x, y, x_new, y_new, vx_half, vy_half, parameters)
    fx_new, fy_new = force(psi_new, x_new, y_new, vx_half, vy_half, parameters)
    vx_new = vx_half + 0.5 * fx_new / mass * current_dt
    vy_new = vy_half + 0.5 * fy_new / mass * current_dt
    
    if parameters.get('debug', False):
        print(f"WARNING: Using minimum dt={current_dt:.2e} after all retries.")
    
    return x_new, y_new, vx_new, vy_new, H_new, psi_new


def evolve_psi(psi, H_old, H_new, dt, x_old, y_old, x_new, y_new, vx, vy, parameters):
    """
    Evolve quantum state using improved RK4 integrator.
    
    Parameters:
    - psi: Current quantum state
    - H_old, H_new: Hamiltonians at old and new positions
    - dt: Time step
    - x_old, y_old, x_new, y_new: Position coordinates
    - vx, vy: Velocity components
    - parameters: Simulation parameters
    
    Returns:
    - Updated quantum state
    """
    try:
        # Calculate midpoint position and Hamiltonian
        x_mid = 0.5 * (x_old + x_new)
        y_mid = 0.5 * (y_old + y_new)
        H_mid = 0.5 * (H_old + H_new)
        
        # Check for NaN values in Hamiltonians
        if np.any(np.isnan(H_old)) or np.any(np.isnan(H_new)) or np.any(np.isnan(H_mid)):
            raise ValueError("NaN detected in Hamiltonian")
        
        # Fourth-order Runge-Kutta for TDSE
        k1 = tdse(psi, H_old, x_old, y_old, vx, vy, parameters)
        k2 = tdse(psi + 0.5 * dt * k1, H_mid, x_mid, y_mid, vx, vy, parameters)
        k3 = tdse(psi + 0.5 * dt * k2, H_mid, x_mid, y_mid, vx, vy, parameters)
        k4 = tdse(psi + dt * k3, H_new, x_new, y_new, vx, vy, parameters)
        
        # Check for NaN values in k coefficients
        if (np.any(np.isnan(k1)) or np.any(np.isnan(k2)) or 
            np.any(np.isnan(k3)) or np.any(np.isnan(k4))):
            raise ValueError("NaN detected in RK4 coefficients")
        
        # RK4 update
        psi_new = psi + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)
        
        # Verify state is valid
        if not np.all(np.isfinite(psi_new)):
            raise ValueError("Non-finite values in quantum state")
        
        # Calculate norm
        norm = np.linalg.norm(psi_new)
        
        # Check norm is reasonable
        if norm < 1e-10:
            raise ValueError("State norm too small")
        
        # Return normalized state
        return psi_new / norm
        
    except Exception as e:
        if parameters.get('debug', False):
            print(f"Warning: State evolution failed: {e}")
        
        # If evolution fails, return normalized original state
        return psi / np.linalg.norm(psi)


def tdse(psi, H, x, y, vx, vy, parameters):
    """
    Time-dependent Schrdinger equation with improved NAC handling.
    
    Parameters:
    - psi: Quantum state
    - H: Hamiltonian matrix
    - x, y: Position coordinates
    - vx, vy: Velocity components
    - parameters: Simulation parameters
    
    Returns:
    - Time derivative of quantum state
    """
    # Complex unit
    iota = 1j
    
    # Standard TDSE term: -i*H*psi
    result = -iota * np.dot(H, psi)
    
    # Add NAC terms if enabled
    if parameters.get('nac', False):
        # Get adiabatic states
        psi_lower, psi_upper = eigenvectors(x, y, parameters)
        
        # Project state onto adiabatic basis
        c_lower = np.vdot(psi_lower, psi)
        c_upper = np.vdot(psi_upper, psi)
        
        # Only include NAC if populations are significant
        if abs(c_lower) > 1e-5 and abs(c_upper) > 1e-5:
            # Calculate NAC vectors
            d_lu_x, d_lu_y = nonadiabatic_coupling(x, y, 'lower', 'upper', parameters)
            
            # Velocity coupling term (dot product of velocity and NAC)
            coupling_term = vx * d_lu_x + vy * d_lu_y
            
            # Avoid numerical issues with phase factor
            if abs(c_upper) < 1e-10:
                phase_factor = 1.0
            else:
                # Calculate phase difference between amplitudes
                phase_factor = np.exp(iota * np.angle(c_lower/c_upper))
            
            # NAC contribution to TDSE
            nac_term = iota * coupling_term * (
                c_upper * psi_lower * phase_factor - 
                c_lower * psi_upper * np.conjugate(phase_factor)
            )
            
            # Add NAC term with safety check
            if np.all(np.isfinite(nac_term)):
                result += nac_term
    
    return result

def initialize_trajectory(parameters, is_prelooping, theta=0.0):
    """
    Initialize trajectories with physically motivated initial conditions.
    No artificial constraints are applied to enforce orbital motion.
    
    Parameters:
    - parameters: Dictionary of simulation parameters
    - is_prelooping: Whether this is a pre-looped trajectory
    - theta: Optional angle parameter (used for testing deterministic outcomes)
    
    Returns:
    - x0, y0, vx0, vy0: Initial position and velocity
    """
    # Define spatial bounds based on parameters
    max_pos = parameters.get('r_max', 5.0)
    
    # Position initialization depends on trajectory type
    if is_prelooping:
        # For pre-looped trajectories: use physics-based initialization
        # Ensure reasonable distance from conical intersection
        r_min = parameters.get('r_min', 0.5)
        r_max = parameters.get('r_max', 5.0)
        
        # Use fixed radius if specified, otherwise random
        if parameters.get('use_fixed_radius', False):
            r = parameters.get('radius', (r_min + r_max)/2)
        else:
            r = np.random.uniform(r_min, r_max)
        
        # Random angle if not specified
        if theta == 0.0:
            theta = np.random.uniform(0, 2*np.pi)
        
        # Handle elliptical coordinates based on eccentricity
        e = parameters.get('e', 0.0)
        x0 = r * np.cos(theta)
        y0 = r * np.sin(theta)
        
        # Adjust y-coordinate for elliptical geometry if needed
        if abs(e) > 1e-6:
            y0 /= np.sqrt(1 - e**2 + 1e-10)  # Avoid division by zero
    else:
        # Regular trajectories: true random initialization
        # Avoid starting exactly at the conical intersection
        while True:
            x0 = np.random.uniform(-max_pos, max_pos)
            y0 = np.random.uniform(-max_pos, max_pos)
            # Ensure we're not too close to the conical intersection
            if x0**2 + y0**2 > 0.25:  # minimum distance from origin
                break
    
    # For all trajectories: physically-motivated velocity scale
    H0 = hamiltonian(x0, y0, parameters)
    eigvals, _ = np.linalg.eigh(H0)
    energy_gap = abs(eigvals[1] - eigvals[0])
    
    # Scale velocity by energy gap (physics-based)
    v_scale = np.sqrt(energy_gap / mass)
    
    if is_prelooping:
        # For pre-looped: initial momentum influenced by Berry curvature
        # This is physics-based, not an artificial constraint
        B = berry_curvature(x0, y0, parameters)
        
        # Use Berry curvature sign to determine rotation direction
        B_sign = np.sign(B) if abs(B) > 1e-10 else 1
        
        # Velocity perpendicular to radial direction (based on physics)
        # Scale velocity moderately by energy gap
        velocity_magnitude = v_scale * 0.5  # Moderate initial velocity
        
        # Set direction perpendicular to position vector (physical)
        vx0 = -B_sign * velocity_magnitude * np.sin(theta)
        vy0 = B_sign * velocity_magnitude * np.cos(theta)
        
        # Apply elliptical correction if needed
        if abs(e) > 1e-6:
            vy0 *= np.sqrt(1 - e**2)
    else:
        # Regular trajectories: random initial velocity
        angle = np.random.uniform(0, 2*np.pi)
        speed_factor = np.random.uniform(0.5, 1.5)  # Variable speed
        vx0 = v_scale * speed_factor * np.cos(angle)
        vy0 = v_scale * speed_factor * np.sin(angle)
    
    return float(x0), float(y0), float(vx0), float(vy0)


def init_state(x, y, parameters, is_prelooping=False):
    """
    Initialize quantum state based on selected basis type.
    
    For pre-looping trajectories:
    - Apply the analytical Berry phase at t=0 only
    - No artificial dynamics are used to accumulate phase
    
    For regular trajectories:
    - Initialize in selected state with optional random phase
    
    Parameters:
    - x, y: Position coordinates
    - parameters: Simulation parameters
    - is_prelooping: Whether to apply the Berry phase at initialization
    
    Returns:
    - Normalized initial quantum state
    """
    # Different initialization based on state type
    state_type = parameters.get('state_type', 'adiabatic')
    
    if state_type == 'adiabatic':
        # Initialize in adiabatic (energy eigenstate) basis
        psi_lower, psi_upper = eigenvectors(x, y, parameters)
        
        # Select initial state based on parameters
        state = psi_upper.copy() if parameters['use_upper_state'] else psi_lower.copy()
        
        # For pre-looping: Apply the Berry phase at t=0
        if is_prelooping and parameters.get('geometric', True):
            which_state = 'upper' if parameters['use_upper_state'] else 'lower'
            phase_value = berry_phase(x, y, parameters, state=which_state)
            state *= np.exp(1j * phase_value)
        elif parameters.get('random_phase', True):
            # Optional random phase for regular trajectories
            state *= np.exp(1j * np.random.uniform(0, 2*np.pi))
            
    elif state_type == 'diabatic':
        # Initialize in diabatic (fixed) basis
        if parameters['use_upper_state']:
            state = np.array([0, 1], dtype=complex)
        else:
            state = np.array([1, 0], dtype=complex)
            
        # For pre-looping: Still apply the Berry phase
        if is_prelooping and parameters.get('geometric', True):
            # Need adiabatic states to calculate proper Berry phase
            psi_lower, psi_upper = eigenvectors(x, y, parameters)
            which_state = 'upper' if parameters['use_upper_state'] else 'lower'
            phase_value = berry_phase(x, y, parameters, state=which_state)
            state *= np.exp(1j * phase_value)
        elif parameters.get('random_phase', True):
            state *= np.exp(1j * np.random.uniform(0, 2*np.pi))
            
    elif state_type == 'gaussian':
        # Initialize as a Gaussian wavepacket
        psi_lower, psi_upper = eigenvectors(x, y, parameters)
        
        # Width parameter from settings
        width = parameters.get('gaussian_width', 0.5)
        
        # Gaussian envelope
        r = np.sqrt(x**2 + y**2)
        envelope = np.exp(-r**2 / (2 * width**2))
        
        # Select state based on parameters
        if parameters['use_upper_state']:
            state = envelope * psi_upper
        else:
            state = envelope * psi_lower
            
        # Apply phase as needed
        if is_prelooping and parameters.get('geometric', True):
            which_state = 'upper' if parameters['use_upper_state'] else 'lower'
            phase_value = berry_phase(x, y, parameters, state=which_state)
            state *= np.exp(1j * phase_value)
        elif parameters.get('random_phase', True):
            state *= np.exp(1j * np.random.uniform(0, 2*np.pi))
    
    # Ensure proper normalization
    return state / np.linalg.norm(state)


def force(psi, x, y, vx, vy, parameters):
    """
    Compute total force based on quantum-classical dynamics.
    No artificial constraints are applied to enforce orbital motion.
    
    Parameters:
    - psi: Current quantum state
    - x, y: Position coordinates
    - vx, vy: Velocity components
    - parameters: Dictionary containing simulation parameters
    
    Returns:
    - fx_total, fy_total: Total physical force components
    """
    # Get adiabatic eigenstates at current position
    psi_lower, psi_upper = eigenvectors(x, y, parameters)
    
    # Project current state onto adiabatic basis
    c_lower = np.vdot(psi_lower, psi)
    c_upper = np.vdot(psi_upper, psi)
    
    # Calculate populations and coherence
    pop_lower = np.abs(c_lower)**2
    pop_upper = np.abs(c_upper)**2
    coherence = np.real(np.conj(c_lower) * c_upper)
    
    # Calculate population difference (for Berry force)
    pop_diff = pop_lower - pop_upper
    
    # Ehrenfest force (gradient of energy)
    dh_x = dh_dx(x, y, parameters)
    dh_y = dh_dy(x, y, parameters)
    fx_ehr = -np.real(np.vdot(psi, np.dot(dh_x, psi)))
    fy_ehr = -np.real(np.vdot(psi, np.dot(dh_y, psi)))
    
    # Initialize total force with Ehrenfest term
    fx_total = fx_ehr
    fy_total = fy_ehr
    
    # Berry curvature force (if enabled)
    if parameters.get('berry', False):
        # Calculate Berry curvature
        B = berry_curvature(x, y, parameters)
        
        # Berry force: F = B  v (weighted by population difference)
        # This is the proper Lorentz-like force from Berry curvature
        fx_berry = B * pop_diff * vy
        fy_berry = -B * pop_diff * vx
        
        fx_total += fx_berry
        fy_total += fy_berry
    
    # Non-adiabatic coupling force (if enabled)
    if parameters.get('nac', False) and pop_lower > 1e-10 and pop_upper > 1e-10:
        # Calculate NAC vectors
        d_lu_x, d_lu_y = nonadiabatic_coupling(x, y, 'lower', 'upper', parameters)
        
        # NAC force proportional to coherence
        fx_nac = -2 * coherence * d_lu_x
        fy_nac = -2 * coherence * d_lu_y
        
        fx_total += fx_nac
        fy_total += fy_nac
        
        # Second-order NAC terms (if enabled)
        if parameters.get('nac2', False):
            d_lu_xx, d_lu_xy, d_lu_yy = second_order_nac(x, y, 'lower', 'upper', parameters)
            fx_nac2 = -coherence * d_lu_xx
            fy_nac2 = -coherence * d_lu_yy
            fx_total += fx_nac2
            fy_total += fy_nac2
    
    # Geometric force from Berry connection (if enabled)
    if parameters.get('geometric', False):
        # Calculate Berry connection
        Ax, Ay = berry_connection(x, y, parameters)
        
        # Calculate derivatives with finite differences
        delta = 1e-5
        Ax1, _ = berry_connection(x + delta, y, parameters)
        Ax2, _ = berry_connection(x - delta, y, parameters)
        _, Ay1 = berry_connection(x, y + delta, parameters)
        _, Ay2 = berry_connection(x, y - delta, parameters)
        
        # Berry connection derivatives
        dAx_dx = (Ax1 - Ax2) / (2 * delta)
        dAy_dy = (Ay1 - Ay2) / (2 * delta)
        
        # Geometric force properly weighted by populations
        fx_geometric = -(pop_lower * dAx_dx + pop_upper * dAx_dx)
        fy_geometric = -(pop_lower * dAy_dy + pop_upper * dAy_dy)
        
        fx_total += fx_geometric
        fy_total += fy_geometric
    
    return fx_total, fy_total

def simulate_trajectory(traj_index, parameters):
    """
    Simulate a single quantum-classical trajectory.
    For pre-looped trajectories, applies Berry phase at t=0 only,
    then lets dynamics evolve naturally without artificial constraints.
    
    Parameters:
    - traj_index: Index of trajectory
    - parameters: Dictionary containing simulation parameters
    
    Returns:
    - Dictionary containing trajectory data
    """
    # Determine trajectory type
    num_pre = parameters.get('num_prelooping', 0)
    is_prelooping = (traj_index < num_pre)
    traj_type = 'prelooping' if is_prelooping else 'regular'
    
    # Allocate storage for trajectory data
    ns = parameters['ns']
    dt = parameters['dt']
    
    traj = {
        'type': traj_type,
        'positions': np.zeros((ns, 2)),
        'momenta': np.zeros((ns, 2)),
        'velocities': np.zeros((ns, 2)),
        'psi_t': np.zeros((ns, 2), dtype=complex),
        'energies': np.zeros(ns),
        'populations': np.zeros((ns, 2)),
        'adiabatic_pops': np.zeros((ns, 2)),
        'berry_curvatures': np.zeros(ns),
        'forces': np.zeros((ns, 2)),
        'warnings': []
    }
    
    # Initialize position and velocity - physics-based, no artificial constraints
    x0, y0, vx0, vy0 = initialize_trajectory(parameters, is_prelooping)
    x, y, vx, vy = x0, y0, vx0, vy0
    
    # Store initial conditions
    traj['initial_position'] = [x0, y0]
    traj['initial_velocity'] = [vx0, vy0]
    traj['is_prelooping'] = is_prelooping
    
    # Compute initial Hamiltonian
    H = hamiltonian(x, y, parameters)
    
    # Initialize quantum state - apply Berry phase at t=0 for pre-looping
    psi0 = init_state(x0, y0, parameters, is_prelooping)
    psi = psi0 / np.linalg.norm(psi0)  # ensure normalization
    
    # Store analytical Berry phase values for analysis
    if is_prelooping:
        traj['lower_cone_berry_phase'] = berry_phase(x0, y0, parameters, state='lower')
        traj['upper_cone_berry_phase'] = berry_phase(x0, y0, parameters, state='upper')
    
    # Main evolution loop - same physics for both trajectory types
    for step in range(ns):
        # Record current state
        traj['positions'][step]  = [x, y]
        traj['velocities'][step] = [vx, vy]
        traj['momenta'][step]    = [mass*vx, mass*vy]
        traj['psi_t'][step]      = psi
        traj['energies'][step]   = np.real(np.vdot(psi, np.dot(H, psi)))
        
        # Record populations in diabatic and adiabatic bases
        psi_lower, psi_upper = eigenvectors(x, y, parameters)
        c_lower = np.vdot(psi_lower, psi)
        c_upper = np.vdot(psi_upper, psi)
        traj['populations'][step]    = [abs(psi[0])**2, abs(psi[1])**2]
        traj['adiabatic_pops'][step] = [abs(c_lower)**2, abs(c_upper)**2]
        
        # Record Berry curvature and force at this step
        traj['berry_curvatures'][step] = berry_curvature(x, y, parameters)
        fx, fy = force(psi, x, y, vx, vy, parameters)
        traj['forces'][step] = [fx, fy]
        
        # Evolve to next step - same physics-based evolution for all trajectories
        if step < ns - 1:
            try:
                x, y, vx, vy, H, psi = evolve_classical(x, y, vx, vy, psi, dt, H, parameters)
            except Exception as e:
                traj['warnings'].append(f"Evolution error at step {step}: {e}")
                break
    
    return traj

def save_trajectories(results, parameters, output_dir, run_id):
    """
    Save trajectory data to HDF5 file
    
    Parameters:
    - results: List of trajectory dictionaries
    - parameters: Dictionary of simulation parameters 
    - output_dir: Directory to save output files
    - run_id: Unique identifier for this simulation run
    """
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Prepare filename with timestamp and run ID
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"{output_dir}/quantum_dynamics_{run_id}_{timestamp}.h5"
    
    with h5py.File(filename, 'w') as f:
        # Store parameters as attributes in root group
        param_group = f.create_group('parameters')
        for key, value in parameters.items():
            # Convert non-scalar parameters to JSON strings
            if isinstance(value, (list, dict, tuple)):
                param_group.attrs[key] = json.dumps(value)
            else:
                try:
                    param_group.attrs[key] = value
                except:
                    param_group.attrs[key] = str(value)
        
        # Store each trajectory in a separate group
        for i, traj in enumerate(results):
            traj_group = f.create_group(f'trajectory_{i}')
            
            # Store trajectory type and other metadata
            traj_group.attrs['type'] = traj['type']
            traj_group.attrs['is_prelooping'] = traj['is_prelooping']
            
            # Store initial conditions
            traj_group.attrs['initial_x'] = traj['initial_position'][0]
            traj_group.attrs['initial_y'] = traj['initial_position'][1]
            traj_group.attrs['initial_vx'] = traj['initial_velocity'][0]
            traj_group.attrs['initial_vy'] = traj['initial_velocity'][1]
            
            # Store Berry phase values if available
            if 'lower_cone_berry_phase' in traj:
                traj_group.attrs['lower_cone_berry_phase'] = traj['lower_cone_berry_phase']
            if 'upper_cone_berry_phase' in traj:
                traj_group.attrs['upper_cone_berry_phase'] = traj['upper_cone_berry_phase']
            
            # Store trajectory data
            traj_group.create_dataset('positions', data=traj['positions'])
            traj_group.create_dataset('velocities', data=traj['velocities'])
            traj_group.create_dataset('momenta', data=traj['momenta'])
            traj_group.create_dataset('psi_t_real', data=np.real(traj['psi_t']))
            traj_group.create_dataset('psi_t_imag', data=np.imag(traj['psi_t']))
            traj_group.create_dataset('energies', data=traj['energies'])
            traj_group.create_dataset('populations', data=traj['populations'])
            traj_group.create_dataset('adiabatic_pops', data=traj['adiabatic_pops'])
            traj_group.create_dataset('berry_curvatures', data=traj['berry_curvatures'])
            traj_group.create_dataset('forces', data=traj['forces'])
            
            # Store warnings if any
            if traj['warnings']:
                traj_group.create_dataset('warnings', data=np.string_(traj['warnings']))
    
    print(f"Trajectory data saved to {filename}")
    return filename

def load_trajectories(filename):
    """
    Load trajectory data from HDF5 file
    
    Parameters:
    - filename: Path to HDF5 file
    
    Returns:
    - results: List of trajectory dictionaries
    - parameters: Dictionary of simulation parameters
    """
    results = []
    parameters = {}
    
    with h5py.File(filename, 'r') as f:
        # Load parameters
        param_group = f['parameters']
        for key in param_group.attrs:
            try:
                # Try to parse JSON strings back to Python objects
                value = param_group.attrs[key]
                if isinstance(value, str) and (value.startswith('{') or value.startswith('[')):
                    parameters[key] = json.loads(value)
                else:
                    parameters[key] = value
            except:
                parameters[key] = param_group.attrs[key]
        
        # Load trajectories
        for traj_name in [k for k in f.keys() if k.startswith('trajectory_')]:
            traj_group = f[traj_name]
            traj = {}
            
            # Load metadata
            traj['type'] = traj_group.attrs['type']
            traj['is_prelooping'] = traj_group.attrs['is_prelooping']
            traj['initial_position'] = [traj_group.attrs['initial_x'], traj_group.attrs['initial_y']]
            traj['initial_velocity'] = [traj_group.attrs['initial_vx'], traj_group.attrs['initial_vy']]
            
            # Load Berry phase values if available
            if 'lower_cone_berry_phase' in traj_group.attrs:
                traj['lower_cone_berry_phase'] = traj_group.attrs['lower_cone_berry_phase']
            if 'upper_cone_berry_phase' in traj_group.attrs:
                traj['upper_cone_berry_phase'] = traj_group.attrs['upper_cone_berry_phase']
            
            # Load trajectory data
            traj['positions'] = traj_group['positions'][()]
            traj['velocities'] = traj_group['velocities'][()]
            traj['momenta'] = traj_group['momenta'][()]
            
            # Reconstruct complex psi values
            psi_real = traj_group['psi_t_real'][()]
            psi_imag = traj_group['psi_t_imag'][()]
            traj['psi_t'] = psi_real + 1j * psi_imag
            
            traj['energies'] = traj_group['energies'][()]
            traj['populations'] = traj_group['populations'][()]
            traj['adiabatic_pops'] = traj_group['adiabatic_pops'][()]
            traj['berry_curvatures'] = traj_group['berry_curvatures'][()]
            traj['forces'] = traj_group['forces'][()]
            
            # Load warnings if any
            if 'warnings' in traj_group:
                warnings_bytes = traj_group['warnings'][()]
                traj['warnings'] = [w.decode('utf-8') for w in warnings_bytes]
            else:
                traj['warnings'] = []
            
            results.append(traj)
    
    return results, parameters

def run_simulation_batch(parameters, output_dir='quantum_dynamics_data', run_id=None):
    """
    Run a batch of trajectories with given parameters and save results
    
    Parameters:
    - parameters: Dictionary of simulation parameters
    - output_dir: Directory to save output files
    - run_id: Unique identifier for this simulation run
    
    Returns:
    - filename: Path to saved data file
    """
    # Generate a unique run ID if not provided
    if run_id is None:
        run_id = f"run_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    print(f"Starting simulation batch {run_id} with {parameters['nt']} trajectories")
    print(f"Parameters: a={parameters['a']}, e={parameters['e']}, s={parameters['s']}")
    
    # Initialize results list
    results = []
    
    # Get number of available CPUs
    num_cpus = mp.cpu_count()
    use_cpus = min(num_cpus, 8)  # Limit to 8 CPUs maximum
    
    print(f"Using {use_cpus} CPUs out of {num_cpus} available")
    
    # Run simulations
    start_time = time.time()
    
    # Determine whether to use parallel processing based on trajectory count
    if parameters['nt'] >= 10 and use_cpus > 1:
        # Parallel processing for many trajectories
        with ProcessPoolExecutor(max_workers=use_cpus) as executor:
            traj_indices = list(range(parameters['nt']))
            traj_params = [parameters] * parameters['nt']
            
            results = list(executor.map(simulate_trajectory, traj_indices, traj_params))
    else:
        # Sequential processing for fewer trajectories
        for i in range(parameters['nt']):
            traj = simulate_trajectory(i, parameters)
            results.append(traj)
            if (i+1) % 10 == 0:
                print(f"Completed {i+1}/{parameters['nt']} trajectories")
    
    end_time = time.time()
    
    print(f"Simulation completed in {end_time - start_time:.2f} seconds")
    
    # Save results to file
    filename = save_trajectories(results, parameters, output_dir, run_id)
    
    return filename

def generate_param_file(param_dict, output_dir='quantum_dynamics_data', filename=None):
    """
    Generate a parameter file that can be used by the batch runner
    
    Parameters:
    - param_dict: Dictionary containing simulation parameters
    - output_dir: Directory to save the parameter file
    - filename: Optional filename for the parameter file
    
    Returns:
    - param_file_path: Path to the generated parameter file
    """
    os.makedirs(output_dir, exist_ok=True)
    
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"params_{timestamp}.json"
    
    param_file_path = os.path.join(output_dir, filename)
    
    with open(param_file_path, 'w') as f:
        json.dump(param_dict, f, indent=2)
    
    print(f"Parameter file generated: {param_file_path}")
    return param_file_path

def parse_command_line():
    """Parse command line arguments for running in batch mode"""
    parser = argparse.ArgumentParser(description='Quantum Dynamics Simulation for HPC')
    
    # Main operation modes
    parser.add_argument('--run', action='store_true', help='Run simulation with parameters from file')
    parser.add_argument('--generate-params', action='store_true', help='Generate parameter file and exit')
    parser.add_argument('--interactive', action='store_true', help='Run in interactive mode (ask for parameters)')
    
    # Parameter sources
    parser.add_argument('--param-file', type=str, help='Path to parameter JSON file')
    
    # Output options
    parser.add_argument('--output-dir', type=str, default='quantum_dynamics_data',
                       help='Directory for output files')
    parser.add_argument('--run-id', type=str, help='Unique identifier for this run')
    
    # Individual parameters (if not using a parameter file)
    parser.add_argument('--a', type=float, default=1.0, help='Constant a for Hamiltonian')
    parser.add_argument('--e', type=float, default=0.8, help='Eccentricity parameter (0  e < 1)')
    parser.add_argument('--s', type=float, default=1.0, help='Scaling factor s')
    parser.add_argument('--z-choice', type=str, choices=['constant', 'function'], default='constant',
                       help='Is z constant or a function')
    parser.add_argument('--z-val', type=float, default=2.0, help='Constant value for z (if z-choice is constant)')
    
    parser.add_argument('--nt', type=int, default=1000, help='Number of trajectories')
    parser.add_argument('--dt', type=float, default=0.01, help='Time step')
    parser.add_argument('--Ttotal', type=float, default=100.0, help='Total simulation time')
    
    parser.add_argument('--r-min', type=float, default=0.5, 
                       help='Minimum radius for pre-looping trajectories')
    parser.add_argument('--r-max', type=float, default=5.0,
                       help='Maximum radius for pre-looping trajectories')
    
    parser.add_argument('--berry', action='store_true', help='Include Berry curvature force')
    parser.add_argument('--num-prelooping', type=int, default=0, 
                       help='Number of pre-looping trajectories (0 to nt)')
    
    parser.add_argument('--state-type', type=str, choices=['adiabatic', 'diabatic', 'gaussian'],
                       default='adiabatic', help='State type for initialization')
    parser.add_argument('--use-upper-state', action='store_true', 
                       help='Use upper state (default is lower state)')
    
    parser.add_argument('--nac', action='store_true', help='Include non-adiabatic coupling')
    parser.add_argument('--nac2', action='store_true', help='Include second-order NAC')
    parser.add_argument('--geometric', action='store_true', help='Include geometric phase')
    
    return parser.parse_args()

def parameters_from_args(args):
    """Convert command line arguments to parameters dictionary"""
    params = {
        'a': args.a,
        'e': args.e,
        's': args.s,
        'z_choice': args.z_choice,
        'z_val': args.z_val,
        'nt': args.nt,
        'dt': args.dt,
        'Ttotal': args.Ttotal,
        'ns': int(np.ceil(args.Ttotal / args.dt)),
        'r_min': args.r_min,
        'r_max': args.r_max,
        'berry': args.berry,
        'num_prelooping': args.num_prelooping,
        'state_type': args.state_type,
        'use_upper_state': args.use_upper_state,
        'nac': args.nac,
        'nac2': args.nac2,
        'geometric': args.geometric,
        'energy_threshold': 1e-4,
        'random_phase': True,
        'debug': False
    }
    
    # Determine upper population based on state choice (for backward compatibility)
    params['upper_pop'] = 1.0 if args.use_upper_state else 0.0
    
    return params

def collect_interactive_parameters():
    """Collect simulation parameters through interactive prompts"""
    print("\nQuantum Dynamics Simulation Parameters for HPC")
    print("=" * 45)
    
    parameters = {}
    
    # System parameters
    print("\nSystem Parameters:")
    parameters['a'] = float(input("Enter constant 'a' for Hamiltonian (default: 1.0): ") or "1.0")
    parameters['e'] = float(input("Enter constant 'e' (0  e  1) (default: 0.8): ") or "0.8")
    parameters['s'] = float(input("Enter scaling factor 's' (default: 1.0): ") or "1.0")
    
    # z-function parameters
    parameters['z_choice'] = input("Is z constant or a function? ('constant' or 'function', default: 'constant'): ").lower() or 'constant'
    if parameters['z_choice'] == 'constant':
        parameters['z_val'] = float(input("Enter constant value for z (default: 2.0): ") or "2.0")
    
    # Trajectory parameters
    print("\nTrajectory Parameters:")
    parameters['r_min'] = float(input("Enter minimum radius for pre-looping trajectories (default: 0.5): ") or "0.5")
    parameters['r_max'] = float(input("Enter maximum radius for pre-looping trajectories (default: 5.0): ") or "5.0")
    parameters['nt'] = int(input("Enter number of trajectories (default: 1000): ") or "1000")
    parameters['dt'] = float(input("Enter time step (default: 0.01): ") or "0.01")
    parameters['Ttotal'] = float(input("Enter total time (default: 100.0): ") or "100.0")
    parameters['ns'] = int(np.ceil(parameters['Ttotal'] / parameters['dt']))  # Number of steps
    
    # Berry phase parameters
    include_berry = input("Include Berry phase for pre-looping trajectories? (yes/no, default: yes): ").lower() != 'no'
    parameters['berry'] = include_berry
    
    if include_berry:
        parameters['num_prelooping'] = int(input(f"Enter number of pre-looping trajectories (0 to {parameters['nt']}, default: 500): ") or "500")
        parameters['num_prelooping'] = min(max(parameters['num_prelooping'], 0), parameters['nt'])
        
        parameters['use_fixed_radius'] = input("Use fixed radius for pre-looping? (yes/no, default: no): ").lower() == 'yes'
        if parameters['use_fixed_radius']:
            default_radius = (parameters['r_min'] + parameters['r_max']) / 2
            parameters['radius'] = float(input(f"Enter fixed radius for pre-looping (default: {default_radius:.1f}): ") or str(default_radius))
    else:
        parameters['num_prelooping'] = 0
        parameters['use_fixed_radius'] = False
    
    # Initial state selection
    print("\nInitial State Configuration:")
    state_choice = input("Choose initial state (1=lower, 2=upper, default: 1): ") or "1"
    parameters['use_upper_state'] = (state_choice == "2")
    
    if parameters['use_upper_state']:
        print("Using pure upper state")
        parameters['upper_pop'] = 1.0  # For backward compatibility
    else:
        print("Using pure lower state")
        parameters['upper_pop'] = 0.0  # For backward compatibility
    
    # For regular trajectories
    parameters['random_phase'] = input("Use random initial phase for regular trajectories? (y/n, default: y): ").lower() != 'n'
    
    # State type selection
    print("\nSelect basis type:")
    print("1. Adiabatic basis")
    print("2. Diabatic basis")
    print("3. Gaussian wavepacket")
    
    state_choice = input("Enter choice (1-3, default: 1): ") or "1"
    state_types = ['adiabatic', 'diabatic', 'gaussian']
    parameters['state_type'] = state_types[int(state_choice) - 1]
    
    # Effect parameters
    print("\nQuantum Effects Options:")
    parameters['nac'] = input("Include non-adiabatic coupling? (y/n, default: n): ").lower() == 'y'
    
    if parameters['nac']:
        parameters['nac2'] = input("Include second-order NAC? (y/n, default: n): ").lower() == 'y'
    else:
        parameters['nac2'] = False
    
    parameters['geometric'] = input("Include geometric phase? (y/n, default: y): ").lower() != 'n'
    
    # Scientific parameters (not artificial constraints)
    parameters['energy_threshold'] = float(input("\nEnergy conservation threshold (default: 1e-4): ") or "1e-4")
    parameters['gaussian_width'] = float(input("Gaussian wavepacket width (if used) (default: 0.5): ") or "0.5")
    parameters['debug'] = input("Show detailed warnings and debug info? (y/n, default: n): ").lower() == 'y'
    
    # Add phase offset parameter for state initialization
    parameters['phase_offset'] = 0.0  # Default phase offset between state components
    
    # Output options
    output_dir = input("\nOutput directory (default: quantum_dynamics_data): ") or "quantum_dynamics_data"
    run_id = input("Run ID (optional, default: auto-generated): ") or None
    
    # Ask if the user wants to save parameters for future runs
    save_params = input("\nSave these parameters to a file for future runs? (y/n, default: y): ").lower() != 'n'
    if save_params:
        generate_param_file(parameters, output_dir)
    
    return parameters, output_dir, run_id

def main():
    """Main entry point for the program"""
    args = parse_command_line()
    
    # Determine operation mode
    if args.interactive:
        # Interactive mode - collect parameters via prompts
        parameters, output_dir, run_id = collect_interactive_parameters()
        
    elif args.generate_params:
        # Generate parameter file only
        parameters = parameters_from_args(args)
        output_dir = args.output_dir
        generate_param_file(parameters, output_dir)
        print("Parameter file generated. Exiting.")
        return
        
    elif args.param_file:
        # Load parameters from file
        with open(args.param_file, 'r') as f:
            parameters = json.load(f)
        output_dir = args.output_dir
        run_id = args.run_id
        
    else:
        # Use command line arguments
        parameters = parameters_from_args(args)
        output_dir = args.output_dir
        run_id = args.run_id
    
    # Run the simulation
    if args.run or args.interactive or args.param_file:
        # Ensure ns is calculated
        if 'ns' not in parameters:
            parameters['ns'] = int(np.ceil(parameters['Ttotal'] / parameters['dt']))
        
        filename = run_simulation_batch(parameters, output_dir, run_id)
        print(f"Simulation complete. Results saved to: {filename}")
    else:
        print("No action specified. Use --run, --generate-params, or --interactive")
        print("For help, use --help")

if __name__ == "__main__":
    main()
